# pandas_test2.py

import pandas as pd
import numpy as np

# Series 클래스
s = pd.Series([9904312, 3448737, 2890451, 2466052], index=['서울','부산','인천','대구'])
print(s)
'''
서울    9904312
부산    3448737
인천    2890451
대구    2466052
dtype: int64
'''

# Series.index 속성 : 인덱스라벨 확인시 사용
print(s.index) # Index(['서울', '부산', '인천', '대구'], dtype='object')

# Series.values 속성 : data 확인시 사용 => np.array() or list() 로 변환시 사용
print(s.values) # [9904312 3448737 2890451 2466052]

# Series.name 속성 : 시리즈에 이름 붙일 수 있음
# index.name 속성 : 시리즈에 인덱스에도 이름을 붙일 수 있음

s.name = '인구'
s.index.name = '도시'
print(s)
'''
도시
서울    9904312
부산    3448737
인천    2890451
대구    2466052
Name: 인구, dtype: int64
'''

# 시리즈 연산
# numpy의 배열 백터화 연산을 Series 에도 사용할 수 있음
# 단, 시리즈의 값에만 연산이 허용됨

# 예 : 인구 숫자를 백만단위로 만들기 위해, 시리즈 객체에 1000000 나누기함
print(s/1000000)
'''
도시
서울    9.904312
부산    3.448737
인천    2.890451
대구    2.466052
Name: 인구, dtype: float64
'''

# 시리즈 인덱싱 : numpy의 배열처럼 인덱시 가능함, 인덱싱에 인덱싱라벨을 사용할 수 있음
# 슬라이싱 시에도 인덱스 라벨을 사용할 수 있음
# 인덱싱하면 값이 반환됨
# print(s[1], s['부산']) # FutureWarning => 사용방식이 변경됨 : `ser.iloc[pos]`
print(s.iloc[1]) # 3448737 # 인덱스 순번(index location)으로 값 가져오기
print(s.loc['부산']) # 3448737 # 인덱스 명(location)으로 가져오기
print(s.부산) # 3448737 # 시리즈변수.인덱스명 으로 값불러오기

# 배열 인덱싱으로 데이터 순서를 바꾸거나, 특정 데이터만 선택할 수 있음
# 시리즈변수.iloc[[순번 나열리스트]], 시리즈변수.loc[[라벨 나열 리스트]]
print(s.iloc[[1,3,0,2]]) # 결과형은 시리즈
'''
도시
부산    3448737
대구    2466052
서울    9904312
인천    2890451
Name: 인구, dtype: int64
'''
print(s.loc[['서울','대구','부산']]) # 결과형은 시리즈
'''
도시
서울    9904312
대구    2466052
부산    3448737
Name: 인구, dtype: int64
'''

# 인구가 250만 초과, 500만 미만인 경우의 값만 출력 : 인덱싱에 조건식 사용 가능함
print(s[(250e4 < s) & (s < 500e4)]) # result type : Series
'''
도시
부산    3448737
인천    2890451
Name: 인구, dtype: int64
'''

# 슬라이싱
print(s[1:3])  # 인덱스 1(이상)부터 3(미만)까지 추출
'''
도시
부산    3448737
인천    2890451
Name: 인구, dtype: int64
'''

print(s['부산':'대구'])  # 인덱스라벨로 슬라이싱 할때는 끝 라벨이 포함됨
'''
도시
부산    3448737
인천    2890451
대구    2466052
Name: 인구, dtype: int64
'''

# 시리즈와 딕셔너리 자료형 적용하면,
# 시리즈의 인덱스라벨이 딕셔너리의 키(key)가 사용됨
# 딕셔너리에서 in 과 item() 함수를 시리즈에도 사용할 수 있음 => 시리즈의 인덱스라벨(키)과 값(value)로 처리함
print('서울' in s) # True # 인덱스 라벨 중에 '서울'이 있느냐 : True
print('대전' in s) # False # 인덱스 라벨 중에 '대전'이 있느냐 : False

for key, value in s.items():
    print('%s = %d' % (key, value))
'''
서울 = 9904312
부산 = 3448737
인천 = 2890451
대구 = 2466052
'''

# 딕셔너리 객체를 시리즈로 변환할 수 있음
dct = {'서울':9904312, '부산':3448737, '인천':2890451, '대전':2466052}
print(dct) # {'서울': 9904312, '부산': 3448737, '인천': 2890451, '대전': 2466052}
s2 = pd.Series(dct) # 딕셔너리 키 작성 순서대로 시리즈 인덱스라벨이 구성됨
print(s2)
'''
서울    9904312
부산    3448737
인천    2890451
대전    2466052
dtype: int64
'''
s2.name = '2020년 인구'
s2.index.name = "도시"
print(s2)
'''
도시
서울    9904312
부산    3448737
인천    2890451
대전    2466052
Name: 2020년 인구, dtype: int64
'''

# 딕셔너리의 값들을 원하는 순서대로 시리즈로 생성되게 하려면, index 속서을 이용함
# key 에 대한 재배치 용도로 속성을 이용함
s3 = pd.Series(dct, index=['부산','대전','인천','서울'])
print(s3)
'''
부산    3448737
대전    2466052
인천    2890451
서울    9904312
dtype: int64
'''
print("=-========================")
# 인덱스기반 연산
s4 = s - s2  # 같은 인덱스라벨 끼리 값 계산됨
print(s4) # 두 시리즈에 라벨이 일치하지 않는 값은 NaN 처리됨
'''
도시
대구    NaN
대전    NaN
부산    0.0
서울    0.0
인천    0.0
dtype: float64
'''

print(s.values-s2.values) # [0 0 0 0] # [......] - [......] => s[0]-s2[0], s[1]-s2[1], ...... ,벡터화연산

# Series.notnull()
# 대구와 대전은 두 시리즈에 모두 존재하지 않기 때문에, 계산이 불가능하므로 NaN(Not a Number) 결과가 나옴
# NaN 은 float 자료형에서만 표현 가능함
# 계산 결과에서 NaN 이 아닌 값들만 추출하려면 notnull() 메소드 사용함
print(s4.notnull()) # NaN : False, 값 : True 로 표현됨
'''
도시
대구    False
대전    False
부산     True
서울     True
인천     True
dtype: bool
'''
print(s4[s4.notnull()]) # True 인 값들만 추출함
'''
도시
부산    0.0
서울    0.0
인천    0.0
dtype: float64
'''

# 인구 증가율(%)을 계산한다면
s5 = (s - s2) / s2 * 100
s5 = s5[s5.notnull()]
print(s5) # 같은 값이라 0.0 으로 출력
'''
도시
부산    0.0
서울    0.0
인천    0.0
dtype: float64
'''

# 시리즈 객체에도 딕셔너리처럼 없는 인덱스라벨로 값 추가할 수 있음
s5['부산'] = 1.63 # 인덱스라벨이 존재하면 갱싱(update)
print(s5)
'''
도시
부산    1.63
서울    0.00
인천    0.00
dtype: float64
'''

s5['대구'] = 1.45 # 없는 인덱스라벨이면 추가(add)
print(s5)
'''
도시
부산    1.63
서울    0.00
인천    0.00
대구    1.45
dtype: float64
'''

# 시리즈의 데이터를 삭제할 때는 del 명령 사용함
del s5['서울']
print(s5)
'''
도시
부산    1.63
인천    0.00
대구    1.45
dtype: float64
'''