# pandas_test7.py

import pandas as pd
import numpy as np

# 시계열 데이터 다루기
# 시간과 날짜 데이터를 시계열 데이터라고 함
# pandas 는 시계열 데이터를 다루려면, 인덱스 자료형을 DatetimeIndex 로 지정해야 함
# DatetimeIndex : 타임스탬프(timestamp) 형식의 특정 시간을 기록하는 시계열 데이터를 다루기 위한 인덱스임
# 타임스탬프 인덱스 라벨은 일정한 간격을 유지할 필요는 없음
# DatetimeIndex 생성함수 : pd.to_datetime(), pd.date_range() 함수 사용함

# pd.to_datetime() 함수
# 날짜, 시간을 나타내는 문자열을 자동으로 datetime 자료형으로 바꾼다음,
# DatetimeIndex 를 생성하는 함수임
date_str = ['2018. 1. 4', '2018. 1. 5', '2024. 11. 27']
idx = pd.to_datetime(date_str)
print(idx) # DatetimeIndex(['2018-01-04', '2018-01-05', '2024-11-27'], dtype='datetime64[ns]', freq=None)

# pd.date_range() 함수
# 모든 날짜, 시간을 일일이 입력하지 않고, 시작일과 종료일 또는 시작일과 간격을 입력하면
# 해당 범위내에 시계열 인덱스를 생성해 주는 함수임
print(pd.date_range('2023-4-1', '2023-4-30'))
'''
DatetimeIndex(['2023-04-01', '2023-04-02', '2023-04-03', '2023-04-04',
               '2023-04-05', '2023-04-06', '2023-04-07', '2023-04-08',
               '2023-04-09', '2023-04-10', '2023-04-11', '2023-04-12',
               '2023-04-13', '2023-04-14', '2023-04-15', '2023-04-16',
               '2023-04-17', '2023-04-18', '2023-04-19', '2023-04-20',
               '2023-04-21', '2023-04-22', '2023-04-23', '2023-04-24',
               '2023-04-25', '2023-04-26', '2023-04-27', '2023-04-28',
               '2023-04-29', '2023-04-30'],
              dtype='datetime64[ns]', freq='D')
'''
print(pd.date_range('2021-12-1',periods=30))
'''
DatetimeIndex(['2021-12-01', '2021-12-02', '2021-12-03', '2021-12-04',
               '2021-12-05', '2021-12-06', '2021-12-07', '2021-12-08',
               '2021-12-09', '2021-12-10', '2021-12-11', '2021-12-12',
               '2021-12-13', '2021-12-14', '2021-12-15', '2021-12-16',
               '2021-12-17', '2021-12-18', '2021-12-19', '2021-12-20',
               '2021-12-21', '2021-12-22', '2021-12-23', '2021-12-24',
               '2021-12-25', '2021-12-26', '2021-12-27', '2021-12-28',
               '2021-12-29', '2021-12-30'],
              dtype='datetime64[ns]', freq='D')
'''
# freq 매개변수로 특정 날짜만 생성되도록  할 수도 있음
# s : 초(second), min: 분(minute), H : 시간(Hour)
# D : 일자(Day), B : 주말이 아닌 평일, W: 주(일요일), W-MON : 주 (월요일, Week-MONDay)
# ME : 각 달(Month)의 마지막 날(End), MS : 각 달의 첫달(Month Start Day)
# BM : 주말이 아닌 평일중에서 각 달의 마지막 날
# BMS : 주말이 아닌 평일중에서 각 달의 첫달
# WOM-2THU : 각 달의 두번째 목요일
# Q-JAN : 각 분기의 첫달의 마지막 날
# Q-DEC : 각 분기의 마지막 달의 마지막 날
# 아래 웹사이트 참조 :
# https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects

print(pd.date_range('2021-12-1','2021-12-30',freq='B'))
'''
DatetimeIndex(['2021-12-01', '2021-12-02', '2021-12-03', '2021-12-06',
               '2021-12-07', '2021-12-08', '2021-12-09', '2021-12-10',
               '2021-12-13', '2021-12-14', '2021-12-15', '2021-12-16',
               '2021-12-17', '2021-12-20', '2021-12-21', '2021-12-22',
               '2021-12-23', '2021-12-24', '2021-12-27', '2021-12-28',
               '2021-12-29', '2021-12-30'],
              dtype='datetime64[ns]', freq='B')

'''
print(pd.date_range('2021-12-1','2021-12-30',freq='W'))
# DatetimeIndex(['2021-12-05', '2021-12-12', '2021-12-19', '2021-12-26'], dtype='datetime64[ns]', freq='W-SUN')
print(pd.date_range('2021-12-1','2021-12-30',freq='W-MON'))
# DatetimeIndex(['2021-12-06', '2021-12-13', '2021-12-20', '2021-12-27'], dtype='datetime64[ns]', freq='W-MON')
print(pd.date_range('2021-12-1','2021-12-30',freq='MS'))
# DatetimeIndex(['2021-12-01'], dtype='datetime64[ns]', freq='MS')
print(pd.date_range('2021-12-1','2021-12-30',freq='ME'))
# DatetimeIndex([], dtype='datetime64[ns]', freq='ME')
print(pd.date_range('2021-12-1','2021-12-30',freq='BMS'))
# DatetimeIndex(['2021-12-01'], dtype='datetime64[ns]', freq='BMS')
print(pd.date_range('2021-12-1','2021-12-30',freq='WOM-2THU'))
# DatetimeIndex(['2021-12-09'], dtype='datetime64[ns]', freq='WOM-2THU')

# shift 연산
# 시계열 데이터 인덱스는 날짜 이동에 대한 연산이 가능함
# shift 연산을 이용하면 인덱스는 그대로 두고, 데이터만 이동시킬 수 있음
np.random.seed(0) # 발생한 랜덤값 고정
ts = pd.Series(np.random.randn(4), index=pd.date_range('2023-1-1',periods=4,freq='ME'))
print(ts)
'''
2023-01-31    1.764052
2023-02-28    0.400157
2023-03-31    0.978738
2023-04-30    2.240893
Freq: ME, dtype: float64
'''
print(ts.shift(1)) # 아래로 1칸 이동
'''
2023-01-31         NaN
2023-02-28    1.764052
2023-03-31    0.400157
2023-04-30    0.978738
Freq: ME, dtype: float64
'''
print(ts.shift(-1)) # 위로 1칸 이동
'''
2023-01-31    0.400157
2023-02-28    0.978738
2023-03-31    2.240893
2023-04-30         NaN
Freq: ME, dtype: float64
'''
print(ts.shift(1,freq='ME')) # 아래로 1칸 이동, 인덱스 라벨도 같이 이동, 1달씩 뒤로밀림
'''
2023-02-28    1.764052
2023-03-31    0.400157
2023-04-30    0.978738
2023-05-31    2.240893
Freq: ME, dtype: float64
'''
print(ts.shift(1,freq='W')) # 아래로 1칸 이동, 인덱스 라벨도 같이 이동, 각 달의 첫주의 일요일 날짜로 이동(변경)
'''
2023-02-05    1.764052
2023-03-05    0.400157
2023-04-02    0.978738
2023-05-07    2.240893
dtype: float64
'''

# resample 연산
# 시간 간격을 재조정할 때 사용함
# 업샘플링 (up - sampling) : 시간 구간을 줄이면 데이터 양이 증가함
# 다운샘플링 (down - sampling) : 시간 구간을 늘리면 데이터 양이 감소함

ts = pd.Series(np.random.randn(100),index=pd.date_range('2022-1-1',periods=100,freq='D'))
print(ts.tail(20))
'''
2022-03-22    1.488252
2022-03-23    1.895889
2022-03-24    1.178780
2022-03-25   -0.179925
2022-03-26   -1.070753
2022-03-27    1.054452
2022-03-28   -0.403177
2022-03-29    1.222445
2022-03-30    0.208275
2022-03-31    0.976639
2022-04-01    0.356366
2022-04-02    0.706573
2022-04-03    0.010500
2022-04-04    1.785870
2022-04-05    0.126912
2022-04-06    0.401989
2022-04-07    1.883151
2022-04-08   -1.347759
2022-04-09   -1.270485
2022-04-10    0.969397
Freq: D, dtype: float64
'''

# 다음샘플링의 경우, 원래 데이터가 그룹으로 묶이기 때문에 group by 와 같은 그룹 연산을 해서 대표값을 구애야 함
print(ts.resample('W').mean())
'''
2022-01-02    0.445140
2022-01-09    0.495067
2022-01-16    0.235301
2022-01-23   -0.130850
2022-01-30    0.068497
2022-02-06    0.071846
2022-02-13   -0.371221
2022-02-20   -0.579260
2022-02-27   -0.175965
2022-03-06   -0.691214
2022-03-13    0.076018
2022-03-20   -0.214814
2022-03-27    0.404350
2022-04-03    0.439660
2022-04-10    0.364154
Freq: W-SUN, dtype: float64
'''
print(ts.resample('MS').mean())
'''
2022-01-01    0.168338
2022-02-01   -0.280265
2022-03-01   -0.005235
2022-04-01    0.362251
Freq: MS, dtype: float64
'''

# 날짜가 아닌 시/분 단위에서는 구간위 왼쪽 한계값(가장 빠른 값)은 포함됨
# 오른쪽 한계값(가장 늦은 값)은 포함 안됨
# 예 : 10분 간격으로 구간을 만들면 10의 배수가 되는 시각은 다음구간의 시작점이 됨

ts = pd.Series(np.random.randn(60),index=pd.date_range('2024-1-1',periods=60,freq='min'))
print(ts.head(20))
'''
2024-01-01 00:00:00   -1.173123
2024-01-01 00:01:00    1.943621
2024-01-01 00:02:00   -0.413619
2024-01-01 00:03:00   -0.747455
2024-01-01 00:04:00    1.922942
2024-01-01 00:05:00    1.480515
2024-01-01 00:06:00    1.867559
2024-01-01 00:07:00    0.906045
2024-01-01 00:08:00   -0.861226
2024-01-01 00:09:00    1.910065
2024-01-01 00:10:00   -0.268003
2024-01-01 00:11:00    0.802456
2024-01-01 00:12:00    0.947252
2024-01-01 00:13:00   -0.155010
2024-01-01 00:14:00    0.614079
2024-01-01 00:15:00    0.922207
2024-01-01 00:16:00    0.376426
2024-01-01 00:17:00   -1.099401
2024-01-01 00:18:00    0.298238
2024-01-01 00:19:00    1.326386
Freq: min, dtype: float64
'''

# 10분 간격으로 구간을 만들어서 계산한다면
print(ts.resample('10min').sum()) # 0분 ~ 9분, 10분~19분,...  구간의 합계
'''
2024-01-01 00:00:00    6.835324
2024-01-01 00:10:00    3.764630
2024-01-01 00:20:00    0.776495
2024-01-01 00:30:00   -0.538336
2024-01-01 00:40:00    1.828234
2024-01-01 00:50:00    0.167957
Freq: 10min, dtype: float64
'''

# 왼쪽(시작값)이 아니라, 오른쪽(끝값)을 구간에 포함하려면
# closed='right' 인수 사용하면 됨(기본은 = 'left')
print(ts.resample('10min',closed = 'right').sum()) # 1분 ~ 10분의 합계
'''
2023-12-31 23:50:00   -1.173123
2024-01-01 00:00:00    7.740444
2024-01-01 00:10:00    3.338065
2024-01-01 00:20:00    0.835217
2024-01-01 00:30:00    2.480654
2024-01-01 00:40:00   -0.653363
2024-01-01 00:50:00    0.266409
Freq: 10min, dtype: float64
'''

# ohlc() 함수 : 구간의 시고저종(opnn, high, low, close)  값을 구함
print(ts.resample('5min').ohlc())
'''
                         open      high       low     close
2024-01-01 00:00:00 -1.173123  1.943621 -1.173123  1.922942
2024-01-01 00:05:00  1.480515  1.910065 -0.861226  1.910065
2024-01-01 00:10:00 -0.268003  0.947252 -0.268003  0.614079
2024-01-01 00:15:00  0.922207  1.326386 -1.099401  1.326386
2024-01-01 00:20:00 -0.694568  1.849264 -0.694568  0.672295
2024-01-01 00:25:00  0.407462  0.539249 -0.769916  0.031831
2024-01-01 00:30:00 -0.635846  0.676433 -0.635846  0.396007
2024-01-01 00:35:00 -1.093062  0.635031 -1.491258  0.635031
2024-01-01 00:40:00  2.383145  2.383145 -1.315907 -1.315907
2024-01-01 00:45:00 -0.461585  1.713343 -0.826439 -0.826439
2024-01-01 00:50:00 -0.098453  1.126636 -1.147469 -1.147469
2024-01-01 00:55:00 -0.437820  1.929532 -0.498032  0.087551 
'''

# 업샘플링의 경우에는 존재하지 않는 데이터를 만들어야 함
# 앞 데이터를 뒤 데이터로 그대로 쓰는 forward filling 방식과
# 뒤 데이터를 앞에서 미리 쓰는 backward Filling 방식이 있음
# bfill(), ffill() 제공함
print(ts.resample('30s').ffill().head(20))
'''
2024-01-01 00:00:00   -1.173123
2024-01-01 00:00:30   -1.173123
2024-01-01 00:01:00    1.943621
2024-01-01 00:01:30    1.943621
2024-01-01 00:02:00   -0.413619
2024-01-01 00:02:30   -0.413619
2024-01-01 00:03:00   -0.747455
2024-01-01 00:03:30   -0.747455
2024-01-01 00:04:00    1.922942
2024-01-01 00:04:30    1.922942
2024-01-01 00:05:00    1.480515
2024-01-01 00:05:30    1.480515
2024-01-01 00:06:00    1.867559
2024-01-01 00:06:30    1.867559
2024-01-01 00:07:00    0.906045
2024-01-01 00:07:30    0.906045
2024-01-01 00:08:00   -0.861226
2024-01-01 00:08:30   -0.861226
2024-01-01 00:09:00    1.910065
2024-01-01 00:09:30    1.910065
Freq: 30s, dtype: float64
'''
print(ts.resample('30s').bfill().head(20))
'''
2024-01-01 00:00:00   -1.173123
2024-01-01 00:00:30    1.943621
2024-01-01 00:01:00    1.943621
2024-01-01 00:01:30   -0.413619
2024-01-01 00:02:00   -0.413619
2024-01-01 00:02:30   -0.747455
2024-01-01 00:03:00   -0.747455
2024-01-01 00:03:30    1.922942
2024-01-01 00:04:00    1.922942
2024-01-01 00:04:30    1.480515
2024-01-01 00:05:00    1.480515
2024-01-01 00:05:30    1.867559
2024-01-01 00:06:00    1.867559
2024-01-01 00:06:30    0.906045
2024-01-01 00:07:00    0.906045
2024-01-01 00:07:30   -0.861226
2024-01-01 00:08:00   -0.861226
2024-01-01 00:08:30    1.910065
2024-01-01 00:09:00    1.910065
2024-01-01 00:09:30   -0.268003
Freq: 30s, dtype: float64
'''

# dt접근자
# datetime 자료형 시리즈에 dt 접근자 제공됨, 속성과 메소드로 제공됨
s = pd.Series(pd.date_range('2023-12-25',periods=100,freq='D'))
print(s)
'''
0    2023-12-25
1    2023-12-26
2    2023-12-27
3    2023-12-28
4    2023-12-29
        ...    
95   2024-03-29
96   2024-03-30
97   2024-03-31
98   2024-04-01
99   2024-04-02
Length: 100, dtype: datetime64[ns]
'''

# year, month, day, weekday 등의 속성을 이용하면, 년, 월, 일 정보를 추출할 수 있음
print(s.dt.year)# 년
'''
0     2023
1     2023
2     2023
3     2023
4     2023
      ... 
95    2024
96    2024
97    2024
98    2024
99    2024
Length: 100, dtype: int32
'''
print(s.dt.weekday) # 요일 # 0 월요일, 6 일요일
'''
0     0
1     1
2     2
3     3
4     4
     ..
95    4
96    5
97    6
98    0
99    1
Length: 100, dtype: int32
'''

# strftime() 함수 : 포맷(format)을 이용해서 날짜 시간 데이터를 문자열로 변환하는 함수
print(s.dt.strftime('%Y 년 %m 월 %d 일'))
'''
0     2023 년 12 월 25 일
1     2023 년 12 월 26 일
2     2023 년 12 월 27 일
3     2023 년 12 월 28 일
4     2023 년 12 월 29 일
            ...       
95    2024 년 03 월 29 일
96    2024 년 03 월 30 일
97    2024 년 03 월 31 일
98    2024 년 04 월 01 일
99    2024 년 04 월 02 일
Length: 100, dtype: object
'''
